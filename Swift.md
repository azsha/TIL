# Swift

### 객체지향 프로그램밍
클래스를 이용한 대규모 프로젝트에 적합하다.
* 데이터 + 매서드 -> 응집력 강화
* 독립적인 디자인 -> 결합력 약화

### 함수형 프로그래밍
대규모 병렬처리가 쉽다.
* 함수를 전달인자로 전달
* 함수를 동적 프로퍼티 할당이 가능
* 함수를 변수나 데이터 구조 안에 담을수 있음
* 함수를 반환 값으로 사용할 수 있음
* 할수를 할당할 때 사용된 이름과 관계없이 고유한 객체로 구별 될 수 있음

Swift는 함수형 프로그래밍 페러다임에 맞는 언어임
다만 iOS 개발이 객체지향 프로그래밍이었기 때문에 궁극적으로 객체지향 + 함수형 모두 포함되어 있음

### 프로토콜 지향의 언어

### dump() 함수
인스턴스의 세부정보까지 로그를 보여주기 때문에 적절하게 사용

### 사용자정의 연산자가 가능
복잡한 연산을 하나의 특수문자로 구현한다면 일반 함수만으로 기능을 수행하는 것 보다 훨씬 강력한 기능이 될 것

### Swift는 Class의 객체를 제외한 모든 것은 Value임

## 함수
* 매개변수 값에 기본값을 부여할 수 있음
* 함수형 프로그래밍 패러다임에 따라 함수는 값을 복사하는 방식으로 수행 -> reference 타입으로 수행 가능하나 추천되지 않음
* 중첩이 가능 -> 함수 안에 함수를 사용가능함

## [옵셔널](http://azsha.tistory.com/75)

## 구조체와 클레스
공통점
* 값을 저장하기 위해 프로퍼티를 정의 가능
* 기능 수행을 휘해 메서드 정의 가능
* 서브스크립트 문법을 통해 프로퍼티에 접근 가능
* 초기화 상태를 위한 이니셜라이저를 정의할 수 있음
* 초기구현과 더불어 익스텐션을 통해 확장이 가능
* 특정 기능을 수행하기 위해 특정 프로토콜을 준수할 수 있음

차이점
* 구조체는 상속할 수 없음
* 타입캐스팅은 클래스의 인스턴스만 가능
* 디이니셜라이저는 클래스의 인스턴스만 가능
* 참조 횟수 계산은 클래스의 인스턴스에만 적용

## 프로퍼티
* 저장프로퍼티 -> 변수, 상수 (var, let)
* 연산프로퍼티 -> 클래스, 구조체, 열거형 (get, set)
* 타입프로퍼티 -> 특정 타입에 사용되는 프로퍼티 (static)
* 프로퍼티 감시자 -> 프로퍼티 값이 변경 될때 마다 액션을 취함 (willSet, didSet)

## 매서드
* 인스턴스 매서드 -> 인스턴스에 속한 매서드
* 타입 매서드 -> 클레스 매서드 (static)

## 인스턴스의 생성
클래스나 구조체, 열거형의 인스턴스를 사용하기전에 초기화 과정을 직접 구현 가능
* (사용자 정의) 이니셜라이저 -> init() 를 통해 가능, 매개 변수 구현 가능, 상수 프로퍼티의 경우도 초기값으로 초기화 가능
* 기본 이니셜라이저 -> 사용자 정의 이니셜 라이저를 사용하지 않는 경우 기본적으로 초기화
* 맴버라이즈 이니셜라이저 -> 클레스에서는 사용 못함, init() 작성하지 않고 프로퍼티 이름으로 초기화를 할 수 있도록 지원함
* 초기화 위임 -> self.init() 를 사용해 이미 작성한 init() 에 초기화 위임이 가능함
* 실패 가능한 이니셜라이저 -> 이니셜라이저가 실패할 경우 nil값으로 반환할 수 있도록 init?() 으로 정의
* 디이니셜라이저 -> 클래스에서만 사용가능 -> 메모리에서 사라지기전에 사용 가능 -> 단 한번만 가능, 매개변수 불가

## 접근제어
접근 수준을 open, public, internal, fileprivate, private 통해 지정할 수 있음
* public -> 어디서든 접근이 가능함, 프레임워크에서 외부와 연결 할때 사용
* open -> 클래스와 클래스 맵버에서만 사용 가능, 현재 클래스를 다른 모듈에서도 부모클래스로 사용하기 위한 목적임을 의미함
* internal -> 기본 접근수준, 구현된 소스파일이 속해있는 모듈 어디에서든 쓰일 수 있음 (외부모듈은 접근 불가)
* fileprivate -> 소스 파일 내부에서만 접근 가능함
* private -> 그 기능이 구현된 범위 내에서만 가능
* 접근 수준은 상위요소보다 하위요소가 더 높은 접근수준을 가질 수 없음

## [클로저](http://azsha.tistory.com/82)

## 맵(Map), 필터(Filter), 리듀스(Reduce)
Swift에서 많이 사용되는 고차 함수(= 고계함수라고도 한다 함수를 인자로 받거나 반환할 수 있는 함수)
* 맵 (Map) -> 자신을 호출할 때 매개변수로 전달된 함수를 실행하여 그 결과를 다시 반환해주는 함수 -> 기존 컨테이너는 변경되지 않고 새로운 컨테이너가 생성되어 반환됨 -> 데이터를 변형할때 사용
* 필터 (Filter) -> 컨테이너 내부의 값을 걸러서 추출하는 역할 -> 매개변수 함수 타입은 Bool -> 새로운 컨테이너에 포함될 항목이면 True, 포함하지 않으면 False를 반환
* 리듀스 (Reduce) -> 컨테이너 내부의 값을 합쳐주는 역할 -> initial이라는 초기값을 지정해줄 수 있음

## 모나드
특정한 값을 담고있는 상자 같은 개념 (예로 옵셔널을 들 수 있다.)
Optional(2) 에서 Optional() 가 Context 이고 이 상태를 모나드라고 한다.

* 맵 (map) - 옵셔널(context)을 넣으면, 옵셔널(context)로 반환 = optional.none
* 플랫맵(flatMap) -  옵셔널(context)을 넣으면, 옵셔널(context) 를 까서 반환해 줌 => nil

## ARC
Swift는 메모리 관리를 위해 ARC를 사용함
Automatic Reference Counting은 참조 타입인 클래스의 인스턴스에만 적용 됨 = 값 타입 해당 사항없음

### ARC VS 가비지 컬렉션
* 컴파일시 결정 VS 동작 중에 결정
* 메모리 해제 시점을 예측 가능 VS 불가능
* 메모리 관리를 위한 시스템 리소스가 필요 없음 VS 필요함 (성능저하)
* 사용법을 모를시 영원히 해제 되지 않는 인스턴스 발생 VS 복잡한 상황에도 해제 가능성이 높음 (특별한 규칙를 생각 안해도 됨)

=> 컴파일 시 결정을 하므로 우리는 미리 메모리 해제 시점을 알려줘야 함

### 강한참조
* 인스턴스가 계속 메모리에 있어야 한다는 것을 알려주는 것이 강한참조
* 인스턴스는 참조 횟수가 0이되는 순간 메모리에서 해제되는데, 그 인스턴스가 다른 인스턴스의 프로퍼티나 변수, 상수 등에 할당할 때 강한 참조를 사용하면 횟수가 1 증가함. 또한 nil을 할당해 주면 1 감소하게 됨
* 참조의 기본은 강한참조이므로 별도의 선언을 하지 않으면 Strong으로 참조됨, 참조 횟수가 0이되면 해당 디이니셜라이즈가 발생함

* 함수(지역변수)안에서 강한참조 +1 -> 함수가 종료될 때 -1 되므로 메모리 해제가 됨
* 함수(지역변수)안에서 강한참조 +1 후 전역변수에 강한참조 +1 를 하는 경우 -> 함수가 종료되어도 -1 메모리 해제가 안됨 (1)
=> "강한참조 순환" 문제 발생

* 두 클레스가 서로의 인스턴스를 참조하는 경우에도 문제가 발생함
A클레스 인스턴스 생성 후 메모리 할당 -> 0 + 1 = 1 (A)
B클레스 인스턴스 생성 후 메모리 할당 -> 0 + 1 = 1 (B)
A클레스 인스턴스에서 B인스턴스 참조 -> 1 + 1 = 2 (A)
B클레스 인스턴스에서 A인스턴스 참조 -> 1 + 1 = 2 (B)
A인스턴스 할당한 변수에 nil -> 2 - 1 = 1 (A)
B인스턴스 할당한 변수에 nil -> 2 - 1 = 1 (B)
=> A, B 인스턴스에 접근할 방법이 없어짐 => "강한참조 순환" 문제 발생

### 약한참조
인스턴스의 참조 횟수를 증가시키지 않음
사용 방법은 "옵셔널" "변수" 선언 앞에 weak 키워드를 넣어주면 됨

### 미소유참조
자신이 참조하는 인스턴스가 반드시 존재할 거라고 생각할 때에 unowned 키워드를 써주면 참조횟수가 늘어나지 않음
하지만 해당 참조가 존재하지 않는 경우에 접근하면 런타임 오류가 발생함

=> 약한 참조는 옵셔널에만 사용이 가능하기 때문에, 암시적 추출 옵셔널 프로퍼티(!)를 사용할 경우에는 미소유 참조를 사용해야 한다.

### 클로저에서의 강한참조 순환
클로저 역시 인스턴스 이기 때문에 강한참조 순환의 문제가 발생할 수 있다.
클레스에 lazy로 선언된 클로저 프로퍼티에서 인스턴스의 다른 프로퍼티를 참조 할 때 문제가 발생한다.
이때 클로저에 약한 참조, 미소유참조를 명시할 수 있는데 {[weak 변수이름, unowned 변수이름] in } 방식으로 사용한다.

=> 이때도 미소유 참조시 참조하려는 인스턴스가 없어지는 경우 오류가 발생하므로 이런 사태를 방지하기 위해 weak으로 사용 할 것을 권장한다.

## 프로토콜
프로토콜이란 매서드, 프로퍼티, 기타 요구사항 등의 청사진을 정의
정의를 할뿐 스스로 기능을 구현하지는 않음

protocol 키워드를 사용해서 구현함
* 읽기 전용 프로퍼티의 경우 { get } 명시
* 읽기 / 쓰기 전용 프로퍼티의 경우 { get set } 명시

## 추가